#include "graphics.h"
#include <FL/Fl.H>
#include <FL/Fl_Window.H>
#include <FL/Fl_Button.H>
#include <FL/FL_Text_Display.H>
#include <vector>
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

vector<Fl_Button *> buttons_list; //vector of buttons


int hide_buttons( vector <int> todelete)
{
     int N = todelete.size();
     int M = buttons_list.size();


     if(N > 1) //searching for the right buttons from the graphic list and hiding them
  {
    int i,j;

       for(i=0; i<N-1; i+=2)
       {
           int a_delete = todelete[i];
           int b_delete = todelete[i+1];


           for(j=0; j < M; j++)
         {
             int a,b;
             a = buttons_list[j] ->y();
             b = buttons_list[j] ->x();

             if(a!=0) a = a /30;
             if(b!=0) b = b /30;

             if(a == a_delete && b == b_delete) //we found a right button
                 {

                   buttons_list[j] -> hide(); //hide the button and erase it from the list, since we don't need it anymore
                   buttons_list.erase(buttons_list.begin() + j);
                   break;
                 }


       }
       }

  }

return N/2; //the number of hidden buttons at the current step
}

void move_buttons_down(vector <int> move_coord)
{
    int N = move_coord.size();
    int M = buttons_list.size();

    for(int i=0; i<N; i+=3)
    {
         int a_move = move_coord[i]; //a and b are the current coordinates
         int b_move = move_coord[i+1];
         int next_y = move_coord[i+2]; // next_y is the new line the button will be onto

         for(int j=0; j < M; j++)
         {
             int a,b;
             a = buttons_list[j] ->y();
             b = buttons_list[j] ->x();

             if(a!=0) a = a /30; //found the right button
             if(b!=0) b = b /30;

             if(a == a_move && b == b_move  ) {buttons_list[j] -> position(b*30, next_y*30);
                                               break;

                                             } //changing coordinates

        }


   }


}


void move_blocks_left(vector <int> move_coord)
{

    int N = move_coord.size();
    int M = buttons_list.size();


    int first_gap = move_coord[0]; //this is the first free cell
    int column = move_coord[1]; //the cell from which we start moving the block
    int dif = column - first_gap; //the difference of coordinates between the previous position and the next one



     for(int j=0; j < M; j++)
         {
             int a,b;

             a = buttons_list[j] ->y(); //line
             b = buttons_list[j] ->x(); //column



             if(b!=0) b = b /30;



             if(b >= column && buttons_list[j] -> visible() )
                {
                    buttons_list[j] -> position( (b - dif)*30, a);
                    buttons_list[j] -> redraw();


                }

         }
}


void button_cb(Fl_Widget* buttonptr, void * adr) //callback function generated by pressing a button
{
   int x,y; //button coordinates
   x = buttonptr -> y(); //for the appropriate coordinates (see the constructor: 30*i, 30*j)
   y = buttonptr -> x(); //coordinates are reversed xoy (on the screen) vs matrix

   if(x!=0) x = x/30;
   if(y!=0) y = y/30;

   World * worldadr = (World*) adr; //the signature of the function requires a void pointer, so we must do a type cast

   int score_buttons = hide_buttons( worldadr -> lee (x, y) ); //this is the score made after the last click
   move_buttons_down ( worldadr -> Move_buttons() );

  // while( worldadr -> Move_blocks() == TRUE)
   vector <int> coord = worldadr -> Move_blocks();
   if (coord.size() > 0 ) move_blocks_left(coord);


    score_buttons += score_buttons/3; //adding extra points for bigger surfaces
    score_buttons = worldadr -> add_points(score_buttons); //updating the general score
    string score;
    score =  static_cast<ostringstream*>( &(ostringstream() << score_buttons) )->str(); // converts an int to a string
    const char *cstr = score.c_str(); //converts a string into a char *


     buttons_list[buttons_list.size() -1]->label(  cstr ); //showing the score in the window


   //while there still are blocks to move

 //  while( coord.size() > 1) {move_blocks_left(coord); coord = worldadr -> Move_blocks();}



}
Graph::Graph(World * new_world, const int number_of_rows, const int number_of_cols) :
    rows(number_of_rows), columns(number_of_cols)
{

    world = new_world;
    world -> Fill();
    //buttons_list.push_back(NULL);

    int i,j;

     // Create a window - width, height, label (=title)
    Fl_Window *win = new Fl_Window(700,400,"Lavinia - Same Game");
    win->color(FL_WHITE);

    // Begin adding children to this window
    win->begin();


    for(i=0; i<rows; i++)
        for(j=0; j<columns; j++)
        {

            int color = world -> get_number(i,j); //returns the number of a specified button from the strategy matrix

            Fl_Button *button = new Fl_Button(30*j,30*i,30,30); //creating new button

            buttons_list.push_back(button); //adding the new button to the button's list




            switch (color)  //color the button
            {
                case(1) : { button->color(FL_RED); button -> label("R"); break;}

                case(2) : { button->color(FL_BLUE); button -> label("B"); break;}

                case(3) : { button->color(FL_YELLOW); button -> label("Y"); break;}

                case(4) : { button->color(FL_GREEN); button -> label("G"); break;}




            }

            //register callback function for every button
             button->callback(button_cb, world); //the parameters are : callback function and a void pointer to world

        }



      Fl_Button *score = new Fl_Button(100,350,100,30); //adding a score cell
      score->color(FL_LIGHT3);
      score->label("0");

      buttons_list.push_back(score); //since we need it to make changes in it, I've put it in the overall buttons list


     win->end();
     // Display the window
     win->show();
     Fl::run();

}
